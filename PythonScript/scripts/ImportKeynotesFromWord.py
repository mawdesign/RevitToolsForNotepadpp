# -*- coding: utf-8 -*-

# This code is currently based on converting the MasterSpec NZ format word document to 
# Revit Keynote format, similar to the MasterSpec MasterKey system. 
# http://www.masterspec.co.nz/masterkey
# A Word export of the specification is parsed extracting all the Section numbers 
# (heading style 1) and sub-headings (heading style 3) from the "4. Selections" sub-section. The section 
# number and sub-heading clause number are combined to create the keynote number, the 
# sub-heading text is used to make the keynote text.
# Further development could add ability to parse MasterSpec pdf exports and other 
# national systems source files.

import zipfile
import xml.etree.ElementTree as ET
import re, string
from tkinter import filedialog as fd

# case options = "none" | "upper" | "lower" | "sentence"
category_case = "none"
keynote_case = "sentence"


def Change_case(text, case="sentence"):

    case_sensitive = [ "uPVC", "S/Steel", ]
    case_sensitive_units = [ "m", "mm", "Pa", "kPa", "MPa", ]
    CONSONANTS = ''.join(set(string.ascii_lowercase) - {'a', 'e', 'i', 'o', 'u', 'y'})
    NUMERALS = string.digits
    PUNCT = r"""!"“#$%&'‘()*+,\-–‒—―./:;?@[\\\]_`{|}~"""
    NZBC_REF = re.compile(r"^[A-H][0-9]{1,2}/(AS|VM)[0-9]+$", re.IGNORECASE)
    UC_INITIALS = re.compile(r"^(?:[A-Z]\.|[A-Z]\.[A-Z])+$", re.IGNORECASE)

    if case == "none":
        return text

    else:
        # Convert  case with an attempt to keep technical abbreviations and anacronyms correct,
        # some ideas are from https://github.com/ppannuto/python-titlecase/blob/main/titlecase/__init__.py

        if case == "upper":
            text = text.upper()
        elif case == "lower":
            text = text.lower()
        elif case == "sentence":
            text = text.capitalize()

        words = re.split('[\t ]', text)
        sc_line = []
        case_sensitive_folded = [w.casefold() for w in case_sensitive_units]

        for word in words:

            # Fix case-sensitive units
            if word.lstrip(NUMERALS + PUNCT).casefold() in case_sensitive_folded:
                i = case_sensitive_folded.index(word.lstrip(NUMERALS + PUNCT).casefold())
                sc_line.append(word[:-len(case_sensitive_units[i])] + case_sensitive_units[i])
                continue

            # Fix case-sensitive words
            if case == "sentence" and word.casefold() in case_sensitive_folded:
                sc_line.append(case_sensitive[case_sensitive_folded.index(word.casefold())])
                continue

            # Fix NZ Building Code references
            if case == "sentence" and NZBC_REF.match(word):
                sc_line.append(word.upper())
                continue

            # Fix dotted anacronyms like S.S.
            if case == "sentence" and UC_INITIALS.match(word):
                sc_line.append(word.upper())
                continue

            # A term with all consonants should be considered an anacronym.  But if it's
            # too short (like "St", don't apply this)
            is_all_consonants = re.search('\A[' + CONSONANTS + PUNCT + NUMERALS + ']+\Z', word, flags=re.IGNORECASE)
            if case == "sentence" and is_all_consonants and len(word) > 1:
                sc_line.append(word.upper())
                continue

            sc_line.append(word)

        text = " ".join(sc_line)

    return text

def main():

    # Get specification file to import
    spec_file = fd.askopenfilename(title="Select Specification", filetypes=[('Word Documents','*.docx'),('All files', '*')])
    if spec_file == "":
        return

    ns = {"w": "http://schemas.openxmlformats.org/wordprocessingml/2006/main",}

    # Create new Notepad++ document
    notepad.new()
    #notepad.runMenuCommand("Encoding", "UTF-16 LE BOM")
    notepad.menuCommand(MENUCOMMAND.FORMAT_UTF_16LE)
    editor.appendText("# Auto-generated by {}\r\n# Imported from {}\r\n".format(__file__[__file__.rfind("\\")+1:], spec_file))
    with zipfile.ZipFile(spec_file) as docx:
        with docx.open('word/document.xml') as doc:
            root = ET.fromstring(doc.read())
            cur_section_no = ""
            selections_section = False
            text = ""
            for p in root.findall(".//w:p", ns):
                text = ""
                h1 = p.find(".//w:pPr/w:pStyle[@w:val='Heading1']/../../w:r/w:t", ns)
                if h1 is not None:
                    cur_section_no = h1.text
                    for t in p.findall(".//w:pPr/w:pStyle[@w:val='Heading1']/../../w:r/w:t", ns):
                        text += Change_case(t.text, category_case) + " "
                    cur_section = text[text.find(" "):].strip()
                    text = ""
                h2 = p.find(".//w:pPr/w:pStyle[@w:val='Heading2']/../../w:r/w:t", ns)
                if h2 is not None:
                    selections_section = True if h2.text.casefold() == "4." else False
                for t in p.findall(".//w:pPr/w:pStyle[@w:val='Heading3']/../../w:r/w:t", ns):
                    text += Change_case(t.text, keynote_case) + " "
                if cur_section_no and selections_section and text:
                    if cur_section != "":
                        editor.appendText("{}\t{}\r\n".format(cur_section_no, cur_section))
                        cur_section = ""
                    editor.appendText("{0} {1}\t{0}\r\n".format(cur_section_no, text.replace(" ", "\t", 1).strip()))

main()
